<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Экшен-путешествие утки</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0b1a2a;
      color: #ffffff;
      font-family: "Segoe UI", Tahoma, sans-serif;
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
    }
    #game-container {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    .hint {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
    }
    #mobile-controls {
      position: fixed;
      bottom: 16px;
      left: 16px;
      display: none;
      grid-template-areas:
        ". up ."
        "left . right"
        ". down .";
      gap: 8px;
      z-index: 5;
      user-select: none;
      touch-action: none;
    }
    #mobile-controls button {
      width: 58px;
      height: 58px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(17, 30, 48, 0.8);
      color: #ffffff;
      font-size: 20px;
      font-weight: 600;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
    }
    #mobile-controls button:active {
      background: rgba(58, 88, 132, 0.9);
    }
    #mobile-controls .up { grid-area: up; }
    #mobile-controls .down { grid-area: down; }
    #mobile-controls .left { grid-area: left; }
    #mobile-controls .right { grid-area: right; }
    @media (orientation: portrait) {
      html, body {
        overflow: hidden;
      }
      #game-container {
        height: 100svh;
      }
    }
    @media (pointer: coarse) {
      #mobile-controls {
        display: grid;
      }
      .hint {
        bottom: 110px;
      }
    }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <div class="hint">Управление: стрелки / WASD / кнопки</div>
  <div id="mobile-controls" aria-label="Мобильное управление">
    <button class="up" data-direction="up">▲</button>
    <button class="left" data-direction="left">◀</button>
    <button class="right" data-direction="right">▶</button>
    <button class="down" data-direction="down">▼</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  <script>
    const config = {
      type: Phaser.AUTO,
      width: 960,
      height: 540,
      parent: 'game-container',
      physics: {
        default: 'arcade',
        arcade: { debug: false }
      },
      scene: { preload, create, update }
    };

    const game = new Phaser.Game(config);

    let duck;
    let cursors;
    let stepIndex = 0;
    let titleText;
    let objectiveText;
    let itemsGroup;
    let hazardGroup;
    let targetZone;
    let scenarioListText;
    let progressText;
    let stepTimer = 0;
    let rescueFound = false;
    let timerText;
    let backgroundLayer;
    const mobileState = { left: false, right: false, up: false, down: false };

    const scenario = [
      {
        title: '1. Вспышка бури',
        description: 'Рывок к укрытию: доберись до высокого камня.',
        type: 'reach',
        target: { x: 160, y: 120 },
        mood: 0x13263d
      },
      {
        title: '2. Турбулентность',
        description: 'Выдержи шторм: уклоняйся от вихрей 8 секунд.',
        type: 'dodge',
        hazardKey: 'gust',
        duration: 8,
        hazards: 3,
        mood: 0x0c1a2c
      },
      {
        title: '3. Прыжки по волнорезам',
        description: 'Пройди через четыре кольца над водой.',
        type: 'rings',
        rings: 4,
        mood: 0x112b3f
      },
      {
        title: '4. Энергия течения',
        description: 'Собери 6 энергетических капсул.',
        type: 'collect',
        itemKey: 'energy',
        count: 6,
        mood: 0x10243a
      },
      {
        title: '5. Охота в небе',
        description: 'Переживи налёт хищника 9 секунд.',
        type: 'dodge',
        hazardKey: 'hawk',
        duration: 9,
        hazards: 2,
        mood: 0x1a2033
      },
      {
        title: '6. Всплеск скорости',
        description: 'Доберись до маяка, пока не истекло время.',
        type: 'reach',
        target: { x: 820, y: 420 },
        mood: 0x0e2435
      },
      {
        title: '7. Прорыв через плотину',
        description: 'Пересекай поток и уклоняйся от катеров 12 секунд.',
        type: 'road',
        duration: 12,
        hazardKey: 'boat',
        mood: 0x0b1a2a
      },
      {
        title: '8. Ночная разведка',
        description: 'Собери 4 светляка, чтобы найти путь.',
        type: 'collect',
        itemKey: 'spark',
        count: 4,
        mood: 0x0a1626
      },
      {
        title: '9. Потерянный утёнок',
        description: 'Найди утёнка и верни к матери.',
        type: 'rescue',
        mood: 0x111a2a
      },
      {
        title: '10. Укрепляем гнездо',
        description: 'Собери 5 пучков камыша под напором ветра.',
        type: 'collect',
        itemKey: 'reeds',
        count: 5,
        mood: 0x0f2030
      },
      {
        title: '11. Финальный вихрь',
        description: 'Вращайся и держи позицию до финального всплеска.',
        type: 'finale',
        mood: 0x14263b
      }
    ];

    function preload() {
      createTexture(this, 'duck', 50, 38, (gfx) => {
        gfx.fillStyle(0xffd166, 1);
        gfx.fillCircle(20, 20, 16);
        gfx.fillCircle(34, 16, 10);
        gfx.fillStyle(0xff9f1c, 1);
        gfx.fillTriangle(42, 18, 54, 22, 42, 26);
        gfx.fillStyle(0x1b1b1b, 1);
        gfx.fillCircle(36, 14, 2);
      });
      createTexture(this, 'mom', 60, 46, (gfx) => {
        gfx.fillStyle(0xffe19c, 1);
        gfx.fillCircle(24, 24, 18);
        gfx.fillCircle(40, 18, 12);
        gfx.fillStyle(0xffb347, 1);
        gfx.fillTriangle(46, 20, 58, 24, 46, 28);
        gfx.fillStyle(0x1b1b1b, 1);
        gfx.fillCircle(42, 16, 2);
      });
      createTexture(this, 'ring', 54, 54, (gfx) => {
        gfx.lineStyle(6, 0x7bdff2, 1);
        gfx.strokeCircle(27, 27, 20);
      });
      createTexture(this, 'energy', 36, 36, (gfx) => {
        gfx.fillStyle(0x66e1ff, 1);
        gfx.fillTriangle(18, 2, 34, 18, 18, 34);
        gfx.fillTriangle(18, 2, 2, 18, 18, 34);
        gfx.lineStyle(2, 0xffffff, 0.8);
        gfx.strokeTriangle(18, 2, 34, 18, 18, 34);
        gfx.strokeTriangle(18, 2, 2, 18, 18, 34);
      });
      createTexture(this, 'hawk', 44, 34, (gfx) => {
        gfx.fillStyle(0xff6b6b, 1);
        gfx.fillTriangle(4, 10, 40, 2, 24, 18);
        gfx.fillTriangle(4, 24, 40, 32, 24, 16);
        gfx.fillStyle(0x1b1b1b, 1);
        gfx.fillCircle(30, 16, 2);
      });
      createTexture(this, 'gust', 48, 48, (gfx) => {
        gfx.lineStyle(4, 0xb3f5ff, 0.8);
        gfx.strokeCircle(24, 24, 18);
        gfx.strokeCircle(24, 24, 10);
      });
      createTexture(this, 'reeds', 34, 50, (gfx) => {
        gfx.fillStyle(0x6bcf6b, 1);
        gfx.fillRect(14, 6, 6, 36);
        gfx.fillRect(6, 10, 6, 30);
        gfx.fillRect(22, 10, 6, 30);
        gfx.fillStyle(0x4a9f4a, 1);
        gfx.fillCircle(17, 6, 6);
      });
      createTexture(this, 'boat', 60, 30, (gfx) => {
        gfx.fillStyle(0xff9f1c, 1);
        gfx.fillRect(6, 10, 48, 12);
        gfx.fillStyle(0x273043, 1);
        gfx.fillRect(18, 4, 16, 8);
      });
      createTexture(this, 'spark', 30, 30, (gfx) => {
        gfx.fillStyle(0xfff3a0, 1);
        gfx.fillCircle(15, 15, 8);
        gfx.lineStyle(2, 0xfff9d9, 0.9);
        gfx.strokeCircle(15, 15, 12);
      });
      createTexture(this, 'duckling', 34, 26, (gfx) => {
        gfx.fillStyle(0x9ad1ff, 1);
        gfx.fillCircle(14, 14, 12);
        gfx.fillCircle(24, 10, 8);
        gfx.fillStyle(0x7fb2ff, 1);
        gfx.fillTriangle(26, 12, 34, 15, 26, 18);
        gfx.fillStyle(0x1b1b1b, 1);
        gfx.fillCircle(24, 8, 2);
      });
    }

    function create() {
      backgroundLayer = this.add.rectangle(480, 270, 960, 540, 0x0b1a2a).setAlpha(1);
      this.add.rectangle(480, 480, 960, 120, 0x0f2438).setAlpha(0.8);

      duck = this.physics.add.sprite(120, 300, 'duck').setScale(0.8);
      duck.setCollideWorldBounds(true);

      const mom = this.add.image(160, 100, 'mom').setScale(0.9);
      mom.setAlpha(0.9);
      mom.setName('mom');

      cursors = this.input.keyboard.createCursorKeys();
      this.input.keyboard.addKeys('W,A,S,D');

      titleText = this.add.text(24, 16, '', { fontSize: '22px', fontStyle: 'bold' });
      objectiveText = this.add.text(24, 48, '', { fontSize: '16px', color: '#dfe7ff' });
      progressText = this.add.text(24, 500, '', { fontSize: '16px', color: '#c0eaff' });
      timerText = this.add.text(800, 16, '', { fontSize: '18px', color: '#ffdf93' });

      const scenarioList = scenario.map(step => step.title).join('\n');
      scenarioListText = this.add.text(720, 120, `Сцены:\n${scenarioList}`,
        { fontSize: '14px', color: '#c6e1ff', align: 'left', wordWrap: { width: 220 } })
        .setAlpha(0.85);

      itemsGroup = this.physics.add.group();
      hazardGroup = this.physics.add.group();

      this.physics.add.overlap(duck, itemsGroup, handleCollect, null, this);
      this.physics.add.overlap(duck, hazardGroup, handleHazard, null, this);

      setupMobileControls();
      setupStep.call(this, 0);
    }

    function update(_, delta) {
      const speed = 200;
      duck.body.setVelocity(0);
      const keys = cursors;
      if (keys.left.isDown || this.input.keyboard.keys[65]?.isDown || mobileState.left) {
        duck.body.setVelocityX(-speed);
      } else if (keys.right.isDown || this.input.keyboard.keys[68]?.isDown || mobileState.right) {
        duck.body.setVelocityX(speed);
      }
      if (keys.up.isDown || this.input.keyboard.keys[87]?.isDown || mobileState.up) {
        duck.body.setVelocityY(-speed);
      } else if (keys.down.isDown || this.input.keyboard.keys[83]?.isDown || mobileState.down) {
        duck.body.setVelocityY(speed);
      }

      if (scenario[stepIndex].type === 'dodge' || scenario[stepIndex].type === 'road') {
        stepTimer -= delta / 1000;
        timerText.setText(`⏱ ${Math.ceil(stepTimer)}с`);
        if (stepTimer <= 0) {
          timerText.setText('');
          nextStep.call(this);
        }
      }

      if (scenario[stepIndex].type === 'reach' && targetZone) {
        const distance = Phaser.Math.Distance.Between(duck.x, duck.y, targetZone.x, targetZone.y);
        if (distance < 40) {
          nextStep.call(this);
        }
      }

      if (scenario[stepIndex].type === 'rings' && itemsGroup.countActive(true) === 0) {
        nextStep.call(this);
      }

      if (scenario[stepIndex].type === 'rescue' && rescueFound && targetZone) {
        const distance = Phaser.Math.Distance.Between(duck.x, duck.y, targetZone.x, targetZone.y);
        if (distance < 40) {
          nextStep.call(this);
        }
      }

      if (scenario[stepIndex].type === 'finale') {
        duck.rotation += 0.02;
      } else {
        duck.rotation = 0;
      }

      if (scenario[stepIndex].type === 'road') {
        hazardGroup.getChildren().forEach(boat => {
          if (boat.x > 1100) {
            boat.x = -200;
          }
        });
      }
    }

    function setupMobileControls() {
      const controls = document.getElementById('mobile-controls');
      if (!controls) {
        return;
      }

      const setDirection = (direction, isActive) => {
        mobileState[direction] = isActive;
      };

      controls.querySelectorAll('button').forEach((button) => {
        const direction = button.dataset.direction;
        button.addEventListener('pointerdown', (event) => {
          event.preventDefault();
          setDirection(direction, true);
        });
        const stop = (event) => {
          event.preventDefault();
          setDirection(direction, false);
        };
        button.addEventListener('pointerup', stop);
        button.addEventListener('pointerleave', stop);
        button.addEventListener('pointercancel', stop);
      });
    }

    function setupStep(index) {
      const step = scenario[index];
      stepIndex = index;
      clearStep.call(this);

      titleText.setText(step.title);
      objectiveText.setText(step.description);
      progressText.setText(`Прогресс: ${index + 1} / ${scenario.length}`);
      backgroundLayer.setFillStyle(step.mood ?? 0x0b1a2a, 1);

      if (step.type === 'reach') {
        targetZone = this.add.circle(step.target.x, step.target.y, 32, 0x7bdff2, 0.35);
        this.add.text(step.target.x - 28, step.target.y - 50, 'Цель', { fontSize: '12px', color: '#ffffff' });
      }

      if (step.type === 'rings') {
        for (let i = 0; i < step.rings; i++) {
          const ring = itemsGroup.create(260 + i * 200, 240 + i * 40, 'ring').setScale(0.5);
          ring.setData('type', 'ring');
        }
      }

      if (step.type === 'collect') {
        for (let i = 0; i < step.count; i++) {
          const item = itemsGroup.create(200 + i * 120, 200 + (i % 2) * 120, step.itemKey).setScale(0.6);
          item.setData('type', 'collect');
        }
      }

      if (step.type === 'dodge') {
        stepTimer = step.duration;
        timerText.setText(`⏱ ${step.duration}с`);
        const hazards = step.hazards ?? 1;
        for (let i = 0; i < hazards; i++) {
          const hazard = hazardGroup.create(300 + i * 160, 200 + i * 80, step.hazardKey).setScale(0.8);
          hazard.setVelocity(120 + i * 40, 90 + i * 30);
          hazard.setCollideWorldBounds(true);
          hazard.setBounce(1);
        }
      }

      if (step.type === 'road') {
        stepTimer = step.duration;
        timerText.setText(`⏱ ${step.duration}с`);
        for (let i = 0; i < 3; i++) {
          const boat = hazardGroup.create(-200 - i * 250, 120 + i * 140, step.hazardKey ?? 'boat').setScale(0.8);
          boat.setVelocity(220 + i * 40, 0);
          boat.setImmovable(true);
        }
      }

      if (step.type === 'rescue') {
        rescueFound = false;
        const duckling = itemsGroup.create(720, 80, 'duckling').setScale(0.6);
        duckling.setData('type', 'rescue');
        targetZone = this.add.circle(140, 100, 32, 0x7be495, 0.35);
        this.add.text(100, 60, 'Мама ждёт', { fontSize: '12px', color: '#ffffff' });
      }

      if (step.type === 'finale') {
        timerText.setText('Финал!');
      }
    }

    function clearStep() {
      itemsGroup.clear(true, true);
      hazardGroup.clear(true, true);
      if (targetZone) {
        targetZone.destroy();
        targetZone = null;
      }
      timerText.setText('');
    }

    function handleCollect(_, item) {
      if (scenario[stepIndex].type === 'collect' || scenario[stepIndex].type === 'rings') {
        item.destroy();
        if (itemsGroup.countActive(true) === 0) {
          nextStep.call(this);
        }
      }
      if (scenario[stepIndex].type === 'rescue' && item.getData('type') === 'rescue') {
        item.destroy();
        rescueFound = true;
        objectiveText.setText('Ты нашёл утёнка! Вернись к маме.');
      }
    }

    function handleHazard(_, hazard) {
      if (scenario[stepIndex].type === 'dodge' || scenario[stepIndex].type === 'road') {
        hazard.setTint(0xff6b6b);
        objectiveText.setText('Удар! Вернись в ритм и попробуй ещё раз.');
        setupStep.call(this, stepIndex);
      }
    }

    function nextStep() {
      if (stepIndex < scenario.length - 1) {
        setupStep.call(this, stepIndex + 1);
      } else {
        titleText.setText('История завершена!');
        objectiveText.setText('Спасибо за игру.');
        progressText.setText('');
      }
    }

    function createTexture(scene, key, width, height, draw) {
      const gfx = scene.make.graphics({ x: 0, y: 0, add: false });
      draw(gfx);
      gfx.generateTexture(key, width, height);
      gfx.destroy();
    }
  </script>
</body>
</html>
